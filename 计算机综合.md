### 1. TCP为什么需要三次握手，采用两次握手可以吗？

建立连接的过程是利用客户端服务器模式，假设主机A为客户端，主机B为服务器端。

(1)TCP的三次握手过程：主机A向主机B发送连接请求，主机B对收到的主机A的报文段进行确认，主机A再次对主机B的确认进行确认。

(2)采用三次握手是为了防止失效的连接请求报文段有传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送链接请求，且建立成功，顺序完成数据传输。考虑到一种特殊情况，主机A第一次发送的请求并没有丢失，而是因为网络结点导致延迟达到主机B,主机B以为主机A发送新的链接请求，于是主机B同意连接，并且向主机A发送确认，但是主机A根本不理会，主机B就一直等待主机A发送数据，导致主机B资源浪费。

(3)采用两次握手不行，原因就是上面说的那种特殊情况。

### 2.为什么建立连接协议是三次握手，而关闭连接却是四次握手？

因为服务器端LISTEN状态下的SOCKET收到SYN报文的建立连接请求后，它可以把 ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了，但未必你所有的数据都传送给对方了，所以你未必马上关闭SOCKET,也就是你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示同意关闭连接了，所以这里的ACK和FIN报文多数是分开来发送的。

### 3.什么是SQL注入式攻击？

所谓 SQL注入攻击就是攻击者把SQL命令插入到web表单的域或页面请求的查询字符串中，欺骗服务器进行恶意的Sql命令。在某些表单中，用户输入的内容直接用来构造动态SQL命令，或作为存储过程的输入参数，这类表单特别容易受到SQL注入式攻击。

应对方法：

1）在利用表单输入的内容构造sql命令之前，对用户的输入进行验证和替换。

2）避免使用解释程序，攻击者一半会借以执行非法命令。

3）对查询字符串、用户名密码等进行加密处理。

4）删除用户输入内容中的所有连字符，防止攻击者顺利获得访问权限。

5）对于用来执行查询的数据库账户，限制权限。

6）用存储过程来执行查询。

7）检查用户输入的合法性，确信输入的内容只有合法数据。数据检查在客户端和服务器端都应该执行。

8）检查提出数据的查询所返回的记录数量。

### 4.进程和线程的区别

进程是具有一定独立功能的程序关于某个数据集合的一次运行活动，是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体，是CPU 调度和分配的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源。

主要区别：

1）一个线程必定属于也只能属于一个进程；而一个进程可以拥有多个线程并且至少具有一个线程。

2）属于一个进程的所有线程共享该进程的资源。

### 5.cache替换算法有哪些

1）随机算法(RAND)

2）先进先出(FIFO)算法

3）近期最少使用(LRU)算法

4）最优替换算法(OPT算法)

5）近期最少使用算法(LFU算法)

#### 6.osi参考模型中，第N层和N+1层之间的关系

第N层是第 N+1层的服务提供者

#### 7.http响应状态码

1XX消息

这一类型的状态码，代表请求已被接受，需要继续处理。这类响应只是临时响应，只包含状态行和某些可选响应头信息，并以空行结束。

* 100 continu

  客户端应该继续发送请求，这个临时响应是用来通知客户端它的部分请求已经被服务器接收，但仍未拒绝。客户端应该继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。


2XX成功

这一类的状态码，代表请求已成功被服务器接收、理解。

* 200 OK

  请求已成功，请求所希望的响头头或数据体将随此响应返回。

* 201 created

  请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，而其URI已经随Location头信息返回。假如需要的资源无法及时建立的话，应当返回'202 Accepted'。

* 202 Accepted

  服务器已经接受请求，但尚未处理。正如它可能被拒绝一样，这个请求可能不会被执行。返回202状态吗的响应的目的允许服务器接收其他请求，而不必让客户端一直保持与服务器的连接知道服务器全部操作完成。

* 203 Non-Authoritative Information

  服务器已成功处理了请求，但返回的实体头部源信息不再原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。

3XX重定向

这类状态吗代表客户端需要进一步的操作才能完成请求。通常这状态码用于重定向，后续的请求地址在本次响应的Location域中指明。

* 301Moved Permanently

  被请求的资源已永久移动到新位置

* 302 Found

  请求的资源现在临时从不同的URI相应请求

* 304 Not modified

  如果客户端发送一个带条件的GET请求且该请求已经被允许

#### 8.死锁

死锁的条件：

* 互斥条件
* 请求和保持条件
* 不可抢占条件
* 循环等待条件

##### 解决死锁的策略：

1）死锁预防：破坏导致死锁必要条件的任意一个就可以预防死锁。

2）死锁避免：避免实质进程在每次申请资源判断这些操作是否安全，比如银行家算法。

3）死锁检测：死锁预防和避免都是事前策略，而死锁的检测是判断系统是否处于死锁状态，如果是，那么执行死锁解除策略。

4）死锁解除：这与死锁检测结合使用，它使用的方式是剥夺。

#### 9.http请求方法

* get
* post
* head
* delete
* put 
* trace 
* connect

#### 10.事务

原子性 一致性 隔离性 永久性

#### 11.http和https的区别是什么

http使用80端口，而https实用的事443端口。http不是安全的，https是安全的。http工作在应用层，而https作用在传输层。http不是加密的，不需要证书，https 是加密的，需要证书。

#### 12.session和cookie的区别是什么

* session保存在服务器端，cookie保存在客户端。
* session默认被存在服务器的一个文件里，session可以保存在文件、数据库或者内存中。
* session的运行依赖session id，而session id是存在cookie中的。

#### 13. ip地址分类

* A类地址的第一组数字为1～126
* B类地址的第一组数字为128～191
* C类地址的第一组数字为192～223

#### 14.索引的优点和缺点

优点：

1）通过创建唯一性的索引，可以保证数据库表中每一行数据的唯一性。

2）可以大大加快数据检索速度。

3）可以加速表和表之间的连接，特别是实现数据的参考完整性方面特别有意义。

4）在使用分组和排序子句进行数据检索时，同样可以显著的减少查询中分组和排序的时间。

5）通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

缺点：

1）创建索引和维护索引需要消耗时间。

2）索引需要占物理空间。

3）对表中的数据进行增删改查的时候，索引也需要动态的维护。

#### 15.linux查看硬盘空间

df命令

#### 16.什么排序元素比较次数和数组初始状态无关

选择排序

#### 17.排序算法比较

| 排序算法 | 平均时间复杂度    | 最好情况       | 最坏情况       | 空间复杂度   | 稳定性  |
| ---- | ---------- | ---------- | ---------- | ------- | ---- |
| 冒泡排序 | O(n^2)     | O(n)       | O(n^2)     | O(1)    | 稳定   |
| 选择排序 | O(n^2)     | O(n^2)     | O(n^2)     | O(1)    | 不稳定  |
| 插入排序 | O(n^2)     | O(n)       | O(n^2)     | O(1)    | 稳定   |
| 希尔排序 | O(nlogn)   | O(nlog^2n) | O(nlog^2n) | O(1)    | 不稳定  |
| 归并排序 | O(nlog(n)) | O(nlogn)   | O(nlogn)   | O(n)    | 稳定   |
| 快速排序 | O(nlogn)   | O(nlogn)   | O(n^2)     | O(logn) | 不稳定  |
| 堆排序  | O(nlogn)   | O(nlogn)   | O(nlogn)   | O(1)    | 不稳定  |
| 计数排序 | O(n+k)     | O(n+k)     | O(n+k)     | O(k)    | 稳定   |
| 桶排序  | O(n+k)     | O(n+k)     | O(n^2)     | O(n+k)  | 稳定   |
| 基数排序 | O(n*k)     | O(n*k)     | O(n*k)     | O(n+k)  | 稳定   |



#### 18.osi七层模型

应用层：允许访问网络资源，通信单位报文。

表示层：数据的转换，甲米，压缩。

会话层：建立，管理，终止会话。

运输层：提供可靠的进程到进程的交付和差错恢复。

网络层：从源到终点传送分组，提供网络互联，通信单位数据报。

数据链路层：将比特组织成帧结构，提供逐条交付。

物理层：经过媒体传送比特。



​       